Node.js试题——面试
================

* [10个常见的Node.js面试题](http://wwsun.github.io/posts/nodejs-interview-questions.html)
* [Node.js面试题，侧重后端应用与对Node核心的理解](https://github.com/jimuyouyou/node-interview-questions)
* [分享几道Nodejs面试题，大家一起来做，有大神回复指点](https://cnodejs.org/topic/56edfa7cb705742136388fb4)
* [Node.js 的面试题是怎么样的？](https://www.zhihu.com/question/24648388)
* [求职面试](http://ourjs.com/home/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/)
* [http://www.100mian.com/category/node-js/](http://www.100mian.com/category/node-js/)

JavaScript语法核心相关的问题，ES6/ES7相关问题，Babel相关问题

Node.js核心相关问题，特性、特点、机制、原理、核心API、理解
Node.js应用相关问题，Express/Koa等Web框架，其他常用第三方模块使用等
Node.js调试技术，调试方式方法手段

HTTP协议相关问题，各个头部字段含义应用
Web前端开发的一些技术问题
Web服务端开发的一些技术问题
Web性能优化要点
Web安全性问题，跨域问题
HTTPS
前后端分离思想，React、Vue等框架相关
RESTful路由

HTTP->WebSocket

异步回掉问题处理方式：async->Promise->Generator->es7:Async/Await

错误处理相关

业务相关：常见的业务场景的处理方式

项目结构/开发规范/发布部署流程/版本控制

`Nginx`、`MySQL`、`MongoDB`、`Redis` 相关软件的使用

MQTT协议

ZooKeeper Kafka RebbitMQ

软件开发思想、方法，软件架构的思考，设计模式、重构、简洁代码、测试

软件开发行为，组织结构，团队协作，管理，需求管理，进度跟踪，bug跟踪，开发周期

## javascript

* 请简要说一下Javascript运行过程。

    JavaScript引擎，不是逐条解释执行javaScript代码，而是按照代码块一段段解释执行:
        * 编译型语言，编译步骤分为：词法分析、语法分析、语义检查、代码优化和字节生成。
        * 解释型语言，通过词法分析和语法分析得到语法分析树后，就可以开始解释执行了。这里是一个简单原始的关于解析过程的原理，仅作为参考，详细的解析过程（各种JS引擎还有不同）还需要更深一步的研究。
    
    JavaScript执行过程，如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：
        * 步骤1. 读入第一个代码段（js执行引擎并非一行一行地执行程序，而是一段一段地分析执行的）
        * 步骤2. 做词法分析和语法分析，有错则报语法错误（比如括号不匹配等），并跳转到步骤5
        * 步骤3. 对【var】变量和【function】定义做“预解析“（永远不会报错的，因为只解析正确的声明）
        * 步骤4. 执行代码段，有错则报错（比如变量未定义）
        * 步骤5. 如果还有下一个代码段，则读入下一个代码段，重复步骤2
        * 步骤6. 结束
    
    关键步骤：
        * 解析：就是通过语法分析和预解析构造合法的语法分析树。
        * 执行：执行具体的某个function，JS引擎在执行每个函数实例时，都会创建一个执行环境（ExecutionContext）和活动对象（activeObject）（它们属于宿主对象，与函数实例的生命周期保持一致）
    
    关键概念：
        * 语法分析树（SyntaxTree）可以直观地表示出这段代码的相关信息，具体的实现就是JS引擎创建了一些表，用来记录每个方法内的变量集（variables），方法集（functions）和作用域（scope）等
        * 执行环境（ExecutionContext）可理解为一个记录当前执行的方法【外部描述信息】的对象,记录所执行方法的类型，名称，参数和活动对象（activeObject）
        * 活动对象（activeObject）可理解为一个记录当前执行的方法【内部执行信息】的对象,记录内部变量集（variables）、内嵌函数集（functions）、实参（arguments）、作用域链（scopeChain）等执行所需信息，其中内部变量集（variables）、内嵌函数集（functions）是直接从第一步建立的语法分析树复制过来的
        * 词法作用域：变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）
        * 作用域链：词法作用域的实现机制就是作用域链（scopeChain）。作用域链是一套按名称查找（Name Lookup）的机制，首先在当前执行环境的 ActiveObject 中寻找，没找到，则顺着作用域链到父 ActiveObject 中寻找，一直找到全局调用对象（Global Object）

* 请简要说一下什么是闭包？闭包有哪些应用？闭包存在什么问题？

    * 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。
    * 闭包有三个特性：1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收
    * 闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。
    * 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
    * 闭包是javascript语言的一大特点，主要应用闭包场合主要是：设计私有的方法和变量。
    * 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！
   
* 请列举一下你所知道的创建对象的各种模式。

    * 工厂模式：解决了创建对象的问题，但是对象无法识别类型，只是一个Object.
    * 构造函数模式：构造函数名字用来标志一个，但是问题在于每个方法在每个对象上都要重新创建一次。
    * 原型模式：每个函数都有一个prototype属性，这是一个指针，指向一个对象。这个对象正可以实现　属性的共享。
    * 组合使用构造函数和原型模式：集 构造函数模式 原型模式 之长，实例属性在构造函数中定义共享属性在原型中定义。默认模式。
    * 动态原型模式：只在第一次调用构造函数时实例化原型。
    * 寄生模式：这种方法 可以用来修改原生对象，在不修改原生对象的前提下，增加方法。
    * 稳妥构造函数模式：适合用于一些安全环境，这些环境禁止使用this和new，防止数据被其他程序改动时使用。
    
* new 操作符都做了什么事？

    * 1.创建一个新对象 
    * 2.将构造函数作用域赋给新对象(this指向了新对象)　
    * 3.执行构造函数中的代码　
    * 4.返回新对象的引用
    * 任何函数　用new来调用就是构造函数 不用new调用就是普通函数

* javascript如何实现继承？

    原型链prototype

* 使用过bind-call-apply三个函数吗？
    
* 有了解过ES6吗？ES6有哪些新特性？

    参考答案：类的支持，模块化，箭头操作符，let/const块作用域，字符串模板，解构，参数默认值/不定参数/拓展参数,for-of遍历,generato r器, Map/Set, Promise
    
* 请说下哪些情况下会造成内存泄漏。    

## Node.JS

* 简要介绍一下Node.JS是什么？能做什么？优缺点？适应场景有哪些？

    Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。
    1. 它是一个Javascript运行环境
    2. 依赖于Chrome V8引擎进行代码解释
    3. 事件驱动
    4. 非阻塞I/O
    5. 轻量、可伸缩，适于实时数据交互应用
    6. 单进程，单线程
    
    1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；
        解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；
    2. 只支持单核CPU，不能充分利用CPU
    3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 原因：单进程，单线程
    
        解决方案：
        * （1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；
        * （2）开多个进程监听同一个端口，使用cluster模块；
        
    4. 开源组件库质量参差不齐，更新快，向下不兼容
    5. Debug不方便，错误没有stack trace

* nodejs模块引入机制是怎样的？

* 你用Node.JS做过哪些有趣的事情？

* 你认为Node.JS在使用的过程中有哪些想比于其他语言很好用的地方？

    单进程、单线程、原生JSON支持 ...

* 你在项目当中是如何处理异步回调的？如何避免回调地狱？

    async Promise：bluebird、Q
　　 
* 什么是错误优先的回调函数？

    错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。

* 在项目中使用过哪些构建工具？哪些工具可以用来保证一致的编程风格？

    grunt、gulp yo  JSLint、JSHint、ESLint、JSCS

* 运行时错误与程序员错误的区别？

    运行时错误不属于bug，这是和系统相关的问题，例如请求超时或者硬件故障。而程序员错误就是所谓的bug。
    但是运行时的错误如果没有被捕获进行相应的处理，就是程序员的错误了。

* 你最喜欢的HTTP框架，并说明原因？

    express、koa、restful、hapi、thinkjs...

* 什么是测试金字塔？对于HTTP API，如何利用测试金字塔？

    在单元测试中：Stub是完全模拟一个外部依赖，而Mock常用来判断测试通过还是失败。
    测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。

* 你使用过哪些测试框架和相关的库？

    mocha、assert、should、chai
    
* 列举在工作中经常使用的模块，并说出其主要用途。

* 请简述一下如何对http body进行解析。
    
* 什么是事件循环？

    http://www.cnblogs.com/yakun/p/3802725.html
    "Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）"
    JavaScript的"并发模型"是基于事件循环的，这个并发模型有别于Java的多线程， javascript的并发是单线程的。
    Javascript 中有个重要一块，Event Loop，能把单线程的 JavaScript 使出 多线程的感觉。
    简单的说，就是在程序中（不一定是浏览器）中跑两个线程，一个负责程序本身的运行，作为主线程； 另一个负责主线程与其他线程的的通信，被称为“Event Loop 线程"。  
    每当遇到异步的 setTimeOut ，setInterval 这些异步任务，交给 EventLoop 线程，然后自己往后运行，等到主线程运行完后，再去 Event Loop 线程拿结果。
    
    一个事件循环指的是——一个实体，它可以处理外部事件并且将它们转化为回调的执行。因此，I/O调用变成了node.js可以从一个请求切换到另外一个请求的“点”，你的代码保存了回调并返回控制权给node.js运行时环境。而回调在最终获得了数据之后被执行。
    当然，在node.js内部，仍然是依靠线程和进程来进行数据访问、处理其他任务执行。然而，这些都没有明确地对你的代码暴露出来，所以你不需要额外担心内部如何处理I/O之间的交互。对比Apache的模型，它少去了很多线程以及线程开销，因为对每个连接来讲单独的线程不是必须的。仅仅是当你绝对需要让某个操作并发执行才会需要线程，但即便如此线程也是node.js自己管理的。
    除了I/O调用之外，node.js期待所有的请求最好快速返回。比如，那些CPU密集型的工作应该被隔离到另一个进程上去执行（通过与事件交互或者使用像WebWorker一样的抽象）。这很明显意味着当你与事件交互的时候，如果没有另一个线程在后端（node.js运行时），那么你是无法并行化执行代码的。基本上，所有可以emit事件的对象（例如EventEmitter的实例）都支持基于事件的异步交互并且你也可以与“blocking code”交互（例如使用文件、sockets或者在node.js中是EventEmitter的子进程）。使用这种方案的话，就能够很好得利用多核的优势了，可以看看:node-http-proxy。

* 谈谈你对事件驱动的理解？

    http://www.jb51.net/article/53812.htm
    事件驱动编程（Evnet-driven programming）是一种编程风格，由事件来决定程序的执行流程，事件由事件处理器（event handler）或事件回调（event callback）来处理，事件回调是当某个特定事件发生时被调用的函数，比如数据库返回了查询结果或者用户单击了一个按钮。
    当你感兴趣的事件发生时会调用你定义的函数，而不是简单的返回结果值，这种编程模型就叫事件驱动编程或异步编程。这是Node一个最明显的特性，这种编程模型意味着当前进程在执行I/O操作时不会被阻塞，因此，多个I/O操作可以并行执行，当操作完成后相应的回调函数就会被调用。
    事件驱动编程底层依赖于事件循环（event loop），事件循环基本上是事件检测和事件处理器触发这两种函数不断循环调用的一个结构。在每次循环里，事件循环机制需要检测发生了哪些事件，当事件发生时，它找到对应的回调函数并调用它。
    事件循环只是运行在进程内的一个线程，当事件发生时，事件处理器可以单独运行并且不会被中断，也就是说：1.在某个特定时刻最多有一个事件回调函数运行 2.任何事件处理器运行时都不会被中断

    Node最初就被设计成一个非阻塞I/O服务器平台，因此一般情况下，你应该期望运行在它上面的所有代码都是非阻塞的。因为JavaScript非常小，而且它不强制使用任何I/O模型（因为它没有标准的I/O类库），因此Node建立在一个很纯净的环境里，不会有什么历史遗留问题。

* 谈谈你对异步回调的理解？

    异步调用在应用程序框架中具有广泛的应用，并且特指多线程情况下。它同Windows的消息循环机制，消息响应，消息队列，事件驱动机制以及设计模式中的观察者模式等都是紧密相关的。 
    在单线程方式下，计算机是一台严格意义上的冯·诺依曼式机器，一段代码调用另一段代码时，只能采用同步调用，必须等待这段代码执行完返回结果后，调用方才能继续往下执行。
    有了多线程的支持，可以采用异步调用，调用方和被调方可以属于两个不同的线程，调用方启动被调方线程后，不等对方返回结果就继续执行后续代码。被调方执行完毕后，通过某种手段通知调用方：结果已经出来，请酌情处理。
    回调函数用于层间协作，上层将本层函数安装在下层，这个函数就是回调，而下层在一定条件下触发回调，例如作为一个驱动，是一个底层，他在收到一个数据时，除了完成本层的处理工作外，还将进行回调，它将这个数据交给上层应用层来做进一步处理，这在分层的数据通信中很普遍。其实回调和API非常接近，他们的共性都是跨层调用的函数。但区别是API是低层提供给高层的调用，一般这个函数对高层都是已知的；而回调正好相反，他是高层提供给底层的调用，对于低层他是未知的，必须由高层进行安装。这个安装函数其实就是一个低层提供的API，安装后低层不知道这个回调的名字，但它通过一个函数指针来保存这个回调，在需要调用时，只需引用这个函数指针和相关的参数指针。  其实：回调就是该函数写在高层，低层通过一个函数指针保存这个函数，在某个事件的触发下，低层通过该函数指针调用高层那个函数。

## 数据库

* 项目中都使用过哪些数据库？分别在项目中起到什么样的作用？

    redis/memcache
    mysql/sqlserver
    mongodb

* 用过哪些数据连接的模块？

* 在使用数据库的过程中有哪些需要注意的地方？

## 项目部署

* 是否熟悉linux常见操作？

* 是否独自安装过node redis mongodb mysql等服务器软件？并进行相应的配置？

* 你是如何进行Node.JS服务部署的？

* 是否对内核进行过优化？进行了哪些优化？

* 是否配置过nginx？都配置了哪些功能？


