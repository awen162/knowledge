# Go

类型的本质？

## 具体类型

## 接口类型

接口类型是对其他类型行为的概括和抽象。

很多面向对象的语言都有接口这个概念，Go语言接口的独特之处在于它是隐式实现的。隐式实现指的是：对于一个具体类型，无须声明它实现了哪些接口，只要提供接口要求的方法即可。这样就可以为已存在的类型增加新的接口，对于那些不能修改的包类型，这点非常有用。

### 接口即约定

具体类型 指定了它所包含的数据的精确的内存布局，同时还暴露了基于这个精确布局的内部操作。你知道了一个具体类型的数据，那么你就精确的知道他是什么以及他能干什么。

一方面，接口类型 要求 调用者 提供的 具体类型 包含一个与其签名和行为一致的方法。
另一方面，接口类型 保证了 调用者 可以提供 任何 满足接口约定的 具体类型 作为参数。

接口类型 仅对 接口 约定的方法有邀请，对 具体类型 没有要求。这种 可以 把 一种类型 替换为 满足同一接口的 另外一种类型的特性（substitutability）是面向对象编程的典型特征。

一个 接口类型 定义了 一套方法，如果一个具体类型要实现该接口，就要实现这套方法。

### 实现接口

如果一个类型实现了 一个接口的所有方法，那么这个类型实现了 这个接口。

Go 程序员通常说一个具体类型 `是一个is-a` X接口，这代表着该具体类型实现了该接口。

对于一个 具体类型T，部分方法的者就是T，而其他方法的接收者是`*T`，同时我们对类型T的变量直接调用`*T`的方法也是合法的，只要该变量是可变的，编译器会隐式地帮你完成取地址操作。

正如信封封装了信件，接口封装了所对应的类型和数据，通过接口类型只能调用接口约定的方法，其他定义的方法则不能通过接口调用。

空接口类型 `interface{}` 不约定任何方法，通过这个接口类型能得到具体类型的什么信息呢？确实什么也得不到。这个时候我们就需要一种方法能够从空接口中还原出实际值，这种方法就是 `类型断言`。

判断是否实现接口只需要比较具体类型和接口类型的方法，所以也就没必要在具体类型的定义中声明这种关系。

http://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html

### 接口值

从概念上，一个接口类型的值包含两部分：一个具体的类型 和 该类型的一个值，二者称为接口的 动态类型 和 动态值。

对于Go这样的静态类型语言，类型仅仅是一个编译时的概念，所以类型并不是一个值。在我们的概念模型中，用 类型描述符 来描述类型，它提供了每个类型的具体信息，它的属性和方法，它的名字。

对于一个接口的值，其类型部分，就用对应的类型描述符来表示。
